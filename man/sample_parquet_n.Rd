% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sample_parquet_n.R
\name{sample_parquet_n}
\alias{sample_parquet_n}
\title{Sample rows from Parquet files using DuckDB reservoir sampling}
\usage{
sample_parquet_n(path, n, seed = NULL, con = NULL)
}
\arguments{
\item{path}{Character scalar. Path or glob pointing to one or more Parquet
files, as understood by DuckDB's \code{parquet_scan()} table function.
For example, \code{"spc_corpus/output/chapter_3/corpus/*.parquet"}.}

\item{n}{Integer scalar. Number of rows to sample. If \code{n} is larger
than the total number of rows in the dataset, DuckDB returns all rows.}

\item{seed}{Optional integer scalar. If supplied, a \code{REPEATABLE(seed)}
clause is added to the DuckDB query so that repeated calls with the same
input data and seed return the same sample. If \code{NULL} (default),
the sample is not forced to be reproducible at the DuckDB level.}

\item{con}{Optional \code{\link[DBI:DBIConnection-class]{DBIConnection}} to
an existing DuckDB database. If \code{NULL} (the default), the function
creates a temporary in-memory DuckDB instance, uses it for the query,
and shuts it down before returning. If a connection is supplied, it is
left open and not modified beyond running the sampling query.}
}
\value{
A \code{data.frame} with up to \code{n} rows, containing a uniform random
sample from the union of all Parquet files matched by \code{path}.
}
\description{
Draw a uniform random sample of \code{n} rows from one or more Parquet files
using DuckDB's SQL \code{USING SAMPLE reservoir(n ROWS)} clause.
The sampling is performed entirely inside DuckDB, so the full dataset
is never loaded into R.

This is well-suited for large Parquet corpora (e.g. OpenAlex works) where
you want a random subset of rows without materialising the whole table.
}
\details{
The function delegates to the following SQL pattern (simplified):

\preformatted{
SELECT *
FROM parquet_scan('path/to/files/*.parquet')
USING SAMPLE reservoir(n ROWS)
[REPEATABLE (seed)]
}

\code{n} from all rows in the dataset (unless \code{n} exceeds the total
row count, in which case all rows are returned).

Note that the \code{path} argument is passed directly to DuckDB's
\code{parquet_scan()} function, so you can use:

\itemize{
  \item A single Parquet file:
    \itemize{\item \code{"works.parquet"}}
  \item A glob for many files:
    \itemize{\item \code{"works/*.parquet"}}
  \item A directory, depending on your DuckDB version/configuration.
}

When \code{con} is \code{NULL}, the function creates an in-memory DuckDB
database. If you want to reuse the same DuckDB instance for multiple queries
(for performance reasons or to control pragmas), you can create a DuckDB
connection yourself and pass it via \code{con}.
}
\examples{
\dontrun{
# Sample 1,000 rows from a directory of Parquet files
sample_df <- sample_parquet_duckdb(
  path = "spc_corpus/output/chapter_3/corpus/*.parquet",
  n = 1000L,
  seed = 1234
)

# Reuse a DuckDB connection for multiple samples
con <- DBI::dbConnect(duckdb::duckdb())
on.exit(DBI::dbDisconnect(con, shutdown = TRUE), add = TRUE)

s1 <- sample_parquet_duckdb(
  path = "openalex_works/*.parquet",
  n = 500L,
  seed = 42,
  con = con
)

s2 <- sample_parquet_duckdb(
  path = "openalex_works/*.parquet",
  n = 500L,
  seed = 777,
  con = con
)
}

}
