---
title: "Compatibility with `openalexR`"
format: 
  html:
    toc: true
    embed-resources: true
params:
  search_term: "biodiversity AND conservation AND IPBES"
  identifier: 
    - "W3045921891"
    - "W3046863325"
  verbose: true
execute: 
  cache: false
  eval: true
---

```{r}
#| include: false
#| label: knitr_setup

try(
  params <- rmarkdown::yaml_front_matter("inst/compatibility.qmd")$params
)

```

```{r}
#| label: setup

library(openalexPro2)
library(openalexR)
library(dplyr)
```

# Compatibility between `openalexR` and `openalexPro`
One of the aims of this package is compatibility with `openalexR::oa_fetch(output = "tibble")`.

Here we will demonstrate how this can be achieved and what the differences are. 

# Get the data

## Search Term Based Search
First we fetch the works using `openalexR::oa_fetch()`:

```{r}
#| label: openalexR_fetch

fn <- file.path("openalexR", "data", "works.rds")

if (!file.exists(fn)) {
  dir.create(dirname(fn), recursive = TRUE, showWarnings = FALSE)
  fetchR <- openalexR::oa_fetch(
    entity = "works",
    output = "tibble",
    title_and_abstract.search = params$search_term,
  ) |>
    dplyr::arrange(id)

  saveRDS(
    fetchR,
    file = fn
  )
}

fetchR <- readRDS(fn)
```

Now we will do the same using the `openalexPro2` pipeline (JSON -> JSONL -> Parquet):

```{r}
#| label: openalexPro_fetch

json_dir <- file.path("openalexPro", "data", "works", "json")
jsonl_dir <- file.path("openalexPro", "data", "works", "jsonl")
fetchPro <- file.path("openalexPro", "data", "works", "corpus")

if (!dir.exists(dirname(fetchPro))) {
  if (dir.exists(json_dir)) {
    unlink(json_dir, recursive = TRUE, force = TRUE)
  }
  if (dir.exists(jsonl_dir)) {
    unlink(jsonl_dir, recursive = TRUE, force = TRUE)
  }
  if (dir.exists(fetchPro)) {
    unlink(fetchPro, recursive = TRUE, force = TRUE)
  }

  fetchPro <- pro_query(
    title_and_abstract.search = params$search_term,
    entity = "works"
  ) |>
    pro_request(
      output = json_dir,
      overwrite = TRUE,
      verbose = params$verbose
    ) |>
    pro_request_jsonl(
      output = jsonl_dir,
      overwrite = TRUE,
      verbose = params$verbose
    ) |>
    pro_request_jsonl_parquet(
      output = fetchPro,
      overwrite = TRUE,
      verbose = params$verbose
    )
}

```

## Snowball Search

First we fetch the works using `openalexR::oa_snowball()`:

```{r}
#| label: openalexR_oa_snowball
fn <- file.path("openalexR", "data", "snowballR.rds")

if (!file.exists(fn)) {
  dir.create(dirname(fn), recursive = TRUE, showWarnings = FALSE)

  snowballR <- openalexR::oa_snowball(
    identifier = params$identifier,
    id_type = "original",
    verbose = params$verbose
  )
  saveRDS(snowballR, fn)
}

snowballR <- readRDS(fn)
```

Now we will do the same using `openalexPro2::pro_snowball()`.

```{r}
#| label: openalexPro_pro_snowball

snowballPro <- file.path("openalexPro", "data", "snowballPro")

if (!dir.exists(snowballPro)) {
  snowballPro <- pro_snowball(
    identifier = params$identifier,
    output = snowballPro,
    verbose = params$verbose
  )
}
```

## Comparison Search Term Search


### Works retrieved (`id`s)

Works retrieved using `openalexR::oa_fetch()` and not in the `openalexPro2` result:

```{r}
setdiff(
  fetchR$id,
  read_corpus(fetchPro, return_data = FALSE) |>
    dplyr::select(id) |>
    dplyr::collect() |>
    dplyr::pull(id)
)
```

Works retrieved using the `openalexPro2` pipeline and not in `openalexR::oa_fetch()`:

```{r}
setdiff(
  read_corpus(fetchPro, return_data = FALSE) |>
    dplyr::select(id) |>
    dplyr::collect() |>
    dplyr::pull(id),
  fetchR$id
)
```

If both are empty, the same works are retrieved.

### Names of Columns

Let's compare the names. The following columns are in both `fetchR` and `fetchPro`:
```{r}
#| label: columns_in_both

intersect(
  names(fetchR),
  read_corpus(fetchPro, return_data = FALSE) |> names()
)
```

The following are missing from `fetchPro`:
```{r}
#| label: columns not_in_fetchPro_comp

setdiff(
  names(fetchR),
  read_corpus(fetchPro, return_data = FALSE) |> names()
)
```

and these are missing from `fetchR`:
```{r}
#| label: columns not_in_fetchR

setdiff(
  read_corpus(fetchPro, return_data = FALSE) |> names(),
  names(fetchR)
)
```


## Comparison Snowball Search


### Nodes - works retrieved (`id`s)

First we check if the same papers are retrieved:.

The following works are in `openalexR::oa_snowball()` but not in `openalexPro2::pro_snowball()`:

```{r}

setdiff(
  snowballR$nodes$id,
  read_snowball(snowballPro, return_data = FALSE)$nodes |>
    dplyr::select(id) |>
    dplyr::mutate(
      id = paste0("https://openalex.org/", id)
    ) |>
    dplyr::collect() |>
    dplyr::pull(id)
)
```

The following works are in `openalexR::oa_snowball()` but not in `openalexPro2::pro_snowball()`:

```{r}
setdiff(
  read_snowball(snowballPro, return_data = FALSE)$nodes |>
    dplyr::select(id) |>
    dplyr::mutate(
      id = paste0("https://openalex.org/", id)
    ) |>
    dplyr::collect() |>
    dplyr::pull(id),
  snowballR$nodes$id
)
```

Both should be empty!

### Edges


#### Edges Identified

The following edges are in `openalexR::oa_snowball()` but not in `openalexPro2::pro_snowball()`:

```{r}
setdiff(
  snowballR$edges |>
  dplyr::arrange(
    from, 
    to
  ),
  read_snowball(snowballPro, return_data = FALSE)$edges |>
    dplyr::filter(edge_type == "core") |>
    dplyr::select(
      from,
      to
    ) |>
    dplyr::mutate(
      from = paste0("https://openalex.org/", from),
      to = paste0("https://openalex.org/", to)
    ) |>
    dplyr::arrange(
      from,
      to
    ) |>
    dplyr::collect()
)
```
  
The following works are in `openalexR::oa_snowball()` but not in `openalexPro2::pro_snowball()`:

```{r}
setdiff(
  read_snowball(snowballPro, return_data = FALSE)$edges |>
    dplyr::filter(edge_type == "core") |>
    dplyr::select(
      from,
      to
    ) |>
    dplyr::mutate(
      from = paste0("https://openalex.org/", from),
      to = paste0("https://openalex.org/", to)
    ) |>
    dplyr::arrange(
      from,
      to
    ) |>
    dplyr::collect(),
  snowballR$edges |>
    dplyr::arrange(
      from,
      to
    )
)
```

